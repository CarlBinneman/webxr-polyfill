<html>
	<head>
		<title>AR anchor example</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body, html {
				padding: 0;
				margin: 0;
				width: 100%;
				height: 100%;
				-webkit-user-select: none;
				user-select: none;
			}
			#target {
				width: 100%;
				height: 100%;
				position: absolute;
			}
			.text-box {
				position: absolute;
				top: 10%;
				left: 50%;
				color: white;
				background: rgba(27,55,55,0.75);;
				outline: 1px solid rgba(127,255,255,0.75);
				border: 0px;
				padding: 5px 10px;
				transform: translate(-50%, -50%);
				font-size: 0.8em;
			}
			.common-message {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: 10px;
			}
		</style>
		<link rel="stylesheet" href="../common.css"/>
		<script src="../libs/three.js"></script>
		<script src="../libs/stats.js"></script>
		<script type="module" src="../../polyfill/XRPolyfill.js"></script>
		<script nomodule src="../../dist/webxr-polyfill.js"></script>
		<script src="../common.js"></script>
	</head>
	<body>
		<div id="target" />
		<div onclick="hideMe(this)" id="description">
			<h2>Simple Computer Vision</h2>
			<h5>(click to dismiss)</h5>
			<p>Compute the average intensity of the video image pixels.</p>
		</div>
		<script>
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
			document.body.appendChild( stats.dom );
			
			class ARAnchorExample extends XRExampleBase {
				constructor(domElement){
					super(domElement, false, true, true)


					this.textBox = document.createElement('span')
					this.textBox.setAttribute('class', 'text-box')
					this.textBox.innerText = '0.0'
					this.intensity = 0;
					this.cr = 0;
					this.cb = 0;
					this.el.appendChild(this.textBox)
				}

				newSession() {
					this.setVideoWorker(ev => { this.handleVideoFrame(ev) })
				}

				// Called during construction
				initializeScene(){
					// Add a box at the scene origin
					let box = new THREE.Mesh(
						new THREE.BoxBufferGeometry(0.1, 0.1, 0.1),
						new THREE.MeshPhongMaterial({ color: '#DDFFDD' })
					)
					box.position.set(0, 0, 0)
					this.floorGroup.add(box)

					this.scene.add(new THREE.AmbientLight('#FFF', 0.2))
					let directionalLight = new THREE.DirectionalLight('#FFF', 0.6)
					directionalLight.position.set(0, 10, 0)
					this.scene.add(directionalLight)
				}

				updateScene(frame){
					stats.update()
					this.textBox.innerHTML = "ARKit Light Estimate: " + frame.lightEstimate.toFixed(2) + "<br>CV Average Intensity: " + this.intensity.toFixed(2)
						+ "<br>Center R/B: " + this.cr.toFixed(2) + " / " + this.cb.toFixed(2);
				}

				//////
				averageIntensity(buffer) {
					//stats.begin();

					var w = buffer.size.width;
					var h = buffer.size.height;
					var pad = buffer.size.bytesPerRow - w;
					var pixels = buffer.buffer;

					var intensity = 0.0;
					var p = 0;
					for (var r = 0; r < h; r++) {
						var v = 0;
						for (var i = 0; i < w; i++) {
							if (p < pixels.length) {
								v += pixels[p++]
							} else {
								console.error("overflow pixel buffer")
							}
						}
						intensity += v / w;
						p += pad;
					}
					this.intensity = (intensity / h) / 255.0;
					//stats.end();
				}

				colorAtCenter(buffer) {
					//stats.begin();

					var w = buffer.size.width;
					var h = buffer.size.height;
					var pixels = buffer.buffer;

					var cx = w   // it's w/2 but then *2 since it's two bytes per!
					var cy = h / 2;
					var p = cy * buffer.size.bytesPerRow + cx;
					this.cb = pixels[p++];
					this.cr = pixels[p];
					//stats.end();
				}


/*
				In the video callback,  ev.detail contains:
					{
					"frame": {
						"buffers": [ // Array of base64 encoded string buffers
						{
							"size": {
							"width": 320,
							"height": 180,
							"bytesPerRow": 384
							},
							"buffer": "e3x...d7d"   /// convert to Uint8 buffer in code below
						},
						{
							"size": {
							"width": 160,
							"height": 90,
							"bytesPerRow": 384
							},
							"buffer": "ZZF.../fIJ7"  /// convert to Uint8 buffer in code below
						}
						],
						"pixelFormatType": "kCVPixelFormatType_420YpCbCr8BiPlanarFullRange",
						"pixelFormat": "YUV420P",  /// Added in the code below, clients should ignore pixelFormatType
						"timestamp": 337791
					},
					"camera": {
						"cameraIntrinsics": [3x3 matrix],
							fx 0   px
							0  fy  py
							0  0   1
							fx and fy are the focal length in pixels.
							px and py are the coordinates of the principal point in pixels.
							The origin is at the center of the upper-left pixel.

						"cameraImageResolution": {
						"width": 1280,
						"height": 720
						},
						"viewMatrix": [4x4 camera view matrix],
						"interfaceOrientation": 3,
							// 0 UIDeviceOrientationUnknown
							// 1 UIDeviceOrientationPortrait
							// 2 UIDeviceOrientationPortraitUpsideDown
							// 3 UIDeviceOrientationLandscapeRight
							// 4 UIDeviceOrientationLandscapeLeft
						"projectionMatrix": [4x4 camera projection matrix]
					}
					}
				*/

				handleVideoFrame(ev) {
					var frame = ev.detail.frame
					var camera = ev.detail.camera
					switch (frame.pixelFormat) {
						case "YUV420P":
						this.averageIntensity(frame.buffers[0])
						this.colorAtCenter(frame.buffers[1])
					}
				}

			}

			window.addEventListener('DOMContentLoaded', () => {
				setTimeout(() => {
					try {
						window.pageApp = new ARAnchorExample(document.getElementById('target'))
					} catch(e) {
						console.error('page error', e)
					}
				}, 1000)
			})
		</script>
	</body>
</html>
